#!/usr/bin/env bash
set -eu

# Quit early if we are in an non-empty directory.
if [[ -n "$(ls -A)" ]]
then
  echo "error: directory is not empty."
  exit 1
fi

# Setup verbose output file descriptor
exec {verbose}>/dev/null
if [[ -v VERBOSE ]]
then
  exec {verbose}>&2
fi

# Parse custom commands
declare -A subject_to_command
while (($#))
do
  argument=$1
  shift
  case $argument in
  "--cmd" )
    if (($# < 2))
    then
      echo "fatal: --cmd argument requires two parameters: the commit and the command"
      exit 1
    fi
    subject=$1
    shift
    cmd=$1
    shift
    subject_to_command[$subject]=$cmd
    ;;
  "--verbose")
    set -x
    exec {verbose}>&2
    ;;
  *)
    echo "fatal: unrecognised argument: $argument"
    exit 1
    ;;
  esac
done

function RUN() {
  echo "RUN $@" >&$verbose
  (eval "$@") 2>&1 | while read line
  do
    echo "| $line" >&$verbose
  done
}

# Init a new repo.
RUN git init

mapfile -t graph < <(git-natp)

declare -A subject_to_hash
declare -a branchnames

ORPHAN_BRANCH="git-natp/orphan-branch"

function create_commit() {
  id="$1"
  subject=$(echo $id | sed 's/_//g')  # Strip disambiguating underscores.
  shift  # Remaining arguments are the parent subjects.
  parents=($@)

  # Translate parent subjects into SHA.
  for i in "${!parents[@]}"
  do
    parent_id=${parents[$i]}
    parents[$i]=${subject_to_hash[$parent_id]}
  done

  # Start with the right HEAD.
  if [[ ${#parents[@]} -gt 0 ]]
  then
    RUN git checkout "${parents[0]}"
  else
    RUN git checkout --orphan "$ORPHAN_BRANCH"
    RUN git rm -rf . || true
  fi

  # Create the commit.
  if [[ ${#parents[@]} -gt 1 ]]
  then
    RUN git merge --allow-unrelated-histories --no-edit -m "$subject" "${parents[@]:1}"
  else
    RUN git commit --allow-empty -m "$subject"
  fi

  # Remove orphan branch if used.
  if [[ ${#parents[@]} -eq 0 ]]
  then
    RUN git checkout $(git rev-list HEAD)
    RUN git branch -d "$ORPHAN_BRANCH"
  fi

  # Dummy file called $id is added to ensure unique commits.
  # Note: we're creating new unique files, one per commit, to make merging easy
  # for those who want to use this tool to create unit tests for a merging tool
  # (for example, me... why else would I make natp?).
  mkdir -p commits
  touch "commits/$id"

  # Run user command for this commit, if any.
  # The user can introduce or change files this way.
  if [[ -v subject_to_command[$id] ]]
  then
    (eval "${subject_to_command[$id]}")
  fi

  # Stage all changes and amend them to our commit.
  RUN git add .
  RUN git commit --amend --no-edit

  # Save the SHA.
  subject_to_hash[$id]="$(git rev-parse HEAD)"
}

function create_branch() {
  branchname=$(echo "$1" | sed 's/\[//g;s/\]//g')
  branchnames+=($branchname)
  commit="$2"
  commit_sha="${subject_to_hash[$commit]}"
  RUN git checkout "$commit_sha"
  RUN git branch "$branchname"
}

BRANCH_LINE_REGEX="^\[[a-zA-Z0-9]+_*\] [a-zA-Z0-9]+_*$"

for line in "${graph[@]}"
do
  if [[ $line =~ $BRANCH_LINE_REGEX ]]
  then
    create_branch $line
  else
    create_commit $line
  fi
done

if [[ ( -v branchnames ) && ( ${#branchnames[@]} > 0 ) ]]
then
  RUN git checkout ${branchnames[0]}
fi
