#!/usr/bin/env bash
set -eu

# Quit early if we are in an non-empty directory.
if [[ -n "$(ls -A)" ]]
then
  echo "error: directory is not empty."
  exit 1
fi

# Init a new repo.
git init >/dev/null

mapfile -t graph < <(git-natp)

declare -A subject_to_hash
declare -a branchnames
declare -A subject_to_files

function create_commit() {
  id="$1"
  subject=$(echo $id | sed 's/_//g')  # Strip disambiguating underscores.
  shift  # Remaining arguments are the parent subjects.
  parents=($@)

  # Start off with our new file.
  files="$id"

  # Translate parent subjects into SHA, and append their files.
  for i in "${!parents[@]}"
  do
    parent_id=${parents[$i]}
    parents[$i]=${subject_to_hash[$parent_id]}
    files="$files ${subject_to_files[$parent_id]}"
  done

  subject_to_files[$id]="$files"

  # Create the commit. Dummy file called $id is added to ensure unique commits.
  # Note: we're creating new unique files, one per commit, to make merging easy
  # for those who want to use this tool to create unit tests for a merging tool
  # (for example, me... why else would I make natp?).
  # Note: files from the parents are also added so that this commit's diff only
  # adds a single file. Files from other branches are deleted.
  rm -rf files
  mkdir files
  cd files
  touch $files
  git add $files >/dev/null
  cd ..
  tree=$(git write-tree)
  sha=$(git commit-tree ${parents[@]/#/-p } -m "$subject" "$tree")
  git checkout "$sha" >/dev/null 2>&1

  # Save the SHA.
  subject_to_hash[$id]="$sha"
}

function create_branch() {
  branchname=$(echo "$1" | sed 's/\[//g;s/\]//g')
  branchnames+=($branchname)
  commit="$2"
  commit_sha="${subject_to_hash[$commit]}"
  git checkout "$commit_sha" >/dev/null 2>&1
  git branch "$branchname" >/dev/null 2>&1
}

BRANCH_LINE_REGEX="^\[[a-zA-Z0-9]+_*\] [a-zA-Z0-9]+_*$"

for line in "${graph[@]}"
do
  if [[ $line =~ $BRANCH_LINE_REGEX ]]
  then
    create_branch $line
  else
    create_commit $line
  fi
done

if [[ ( -v branchnames ) && ( ${#branchnames[@]} > 0 ) ]]
then
  git checkout ${branchnames[0]} >/dev/null 2>&1
fi
